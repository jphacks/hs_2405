{"ast":null,"code":"import { collection, query, where, getDocs, addDoc } from 'firebase/firestore';\nimport { db } from './firebase';\nexport async function checkMutualLike(userId) {\n  try {\n    // 1. `userId`が「いいね」したすべてのユーザーを取得\n    const likeFromUserQuery = query(collection(db, 'Likes'), where('fromUserId', '==', userId), where('evaluation', '==', 'like'));\n    const likeFromUserSnapshot = await getDocs(likeFromUserQuery);\n    const likedUserIds = likeFromUserSnapshot.docs.map(doc => doc.data().toUserId);\n\n    // 2. `userId`に「いいね」しているユーザーを一度に取得\n    const likeToUserQuery = query(collection(db, 'Likes'), where('toUserId', '==', userId), where('evaluation', '==', 'like'));\n    const likeToUserSnapshot = await getDocs(likeToUserQuery);\n    const mutualUserIds = likeToUserSnapshot.docs.map(doc => doc.data().fromUserId);\n\n    // 3. 双方のリストに共通するユーザーのみを抽出してマッチを保存\n    const mutualLikes = likedUserIds.filter(likedUserId => mutualUserIds.includes(likedUserId));\n\n    // 4. マッチを双方向に保存\n    for (const matchedUserId of mutualLikes) {\n      // 両方のユーザー間でマッチが保存されていない場合のみ保存\n      const matchExistsQuery = query(collection(db, 'UserMatches'), where('userId', '==', userId), where('matchedUserId', '==', matchedUserId));\n      const reverseMatchExistsQuery = query(collection(db, 'UserMatches'), where('userId', '==', matchedUserId), where('matchedUserId', '==', userId));\n      const [matchExistsSnapshot, reverseMatchExistsSnapshot] = await Promise.all([getDocs(matchExistsQuery), getDocs(reverseMatchExistsQuery)]);\n\n      // 双方向にマッチが保存されていなければ新たに保存\n      if (matchExistsSnapshot.empty && reverseMatchExistsSnapshot.empty) {\n        await Promise.all([addDoc(collection(db, 'UserMatches'), {\n          userId: userId,\n          matchedUserId: matchedUserId,\n          timestamp: new Date()\n        }), addDoc(collection(db, 'UserMatches'), {\n          userId: matchedUserId,\n          matchedUserId: userId,\n          timestamp: new Date()\n        })]);\n        console.log(`相互マッチが保存されました: ${userId} と ${matchedUserId}`);\n      } else {\n        console.log(`既にマッチが存在しています: ${userId} と ${matchedUserId}`);\n      }\n    }\n  } catch (error) {\n    console.error('マッチングエラー:', error);\n  }\n}","map":{"version":3,"names":["collection","query","where","getDocs","addDoc","db","checkMutualLike","userId","likeFromUserQuery","likeFromUserSnapshot","likedUserIds","docs","map","doc","data","toUserId","likeToUserQuery","likeToUserSnapshot","mutualUserIds","fromUserId","mutualLikes","filter","likedUserId","includes","matchedUserId","matchExistsQuery","reverseMatchExistsQuery","matchExistsSnapshot","reverseMatchExistsSnapshot","Promise","all","empty","timestamp","Date","console","log","error"],"sources":["/Users/shuga/hs_2405/src/checkMutualLike.js"],"sourcesContent":["import { collection, query, where, getDocs, addDoc } from 'firebase/firestore';\nimport { db } from './firebase';\n\nexport async function checkMutualLike(userId) {\n  try {\n    // 1. `userId`が「いいね」したすべてのユーザーを取得\n    const likeFromUserQuery = query(\n      collection(db, 'Likes'),\n      where('fromUserId', '==', userId),\n      where('evaluation', '==', 'like')\n    );\n    const likeFromUserSnapshot = await getDocs(likeFromUserQuery);\n    const likedUserIds = likeFromUserSnapshot.docs.map(doc => doc.data().toUserId);\n\n    // 2. `userId`に「いいね」しているユーザーを一度に取得\n    const likeToUserQuery = query(\n      collection(db, 'Likes'),\n      where('toUserId', '==', userId),\n      where('evaluation', '==', 'like')\n    );\n    const likeToUserSnapshot = await getDocs(likeToUserQuery);\n    const mutualUserIds = likeToUserSnapshot.docs.map(doc => doc.data().fromUserId);\n\n    // 3. 双方のリストに共通するユーザーのみを抽出してマッチを保存\n    const mutualLikes = likedUserIds.filter(likedUserId => mutualUserIds.includes(likedUserId));\n\n    // 4. マッチを双方向に保存\n    for (const matchedUserId of mutualLikes) {\n      // 両方のユーザー間でマッチが保存されていない場合のみ保存\n      const matchExistsQuery = query(\n        collection(db, 'UserMatches'),\n        where('userId', '==', userId),\n        where('matchedUserId', '==', matchedUserId)\n      );\n      const reverseMatchExistsQuery = query(\n        collection(db, 'UserMatches'),\n        where('userId', '==', matchedUserId),\n        where('matchedUserId', '==', userId)\n      );\n\n      const [matchExistsSnapshot, reverseMatchExistsSnapshot] = await Promise.all([\n        getDocs(matchExistsQuery),\n        getDocs(reverseMatchExistsQuery),\n      ]);\n\n      // 双方向にマッチが保存されていなければ新たに保存\n      if (matchExistsSnapshot.empty && reverseMatchExistsSnapshot.empty) {\n        await Promise.all([\n          addDoc(collection(db, 'UserMatches'), {\n            userId: userId,\n            matchedUserId: matchedUserId,\n            timestamp: new Date()\n          }),\n          addDoc(collection(db, 'UserMatches'), {\n            userId: matchedUserId,\n            matchedUserId: userId,\n            timestamp: new Date()\n          })\n        ]);\n        console.log(`相互マッチが保存されました: ${userId} と ${matchedUserId}`);\n      } else {\n        console.log(`既にマッチが存在しています: ${userId} と ${matchedUserId}`);\n      }\n    }\n  } catch (error) {\n    console.error('マッチングエラー:', error);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}